{
  "name": "streamee",
  "version": "0.5.3",
  "description": "Easy stream transformation and composition for node.js that integrates seamlessly with Q promises",
  "keywords": [
    "stream",
    "promise",
    "map",
    "filter",
    "flatten",
    "functional",
    "transformation",
    "composition"
  ],
  "author": {
    "name": "Alexandre Tamborrino",
    "email": "tamborrino.alexandre@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/atamborrino/streamee.js.git"
  },
  "main": "index",
  "homepage": "https://github.com/atamborrino/streamee.js",
  "bugs": {
    "url": "https://github.com/atamborrino/streamee.js/issues"
  },
  "dependencies": {
    "underscore": "1.4.4",
    "q": "0.9.3"
  },
  "devDependencies": {
    "mocha": "1.9.0",
    "should": "1.2.2"
  },
  "licenses": [
    {
      "type": "Apache 2"
    }
  ],
  "readme": "# streamee.js\n\nStreamee.js is a set of stream transformers and composers for node.js that integrates seamlessly with [Q promises](https://github.com/kriskowal/q). It can be seen as a mix of [async](https://github.com/caolan/async) and [underscore.js](http://underscorejs.org/), but for streams!\n\nOne of the most useful feature of streams is **back-pressure**: if the bottom of the stream pipeline is slow (for example the Web client), then the top will automatically push slowly (for example your database and/or Web server). As a result memory and CPU consumption in node are optimal.  \nStreamee.js allows you to build very easily pipelines that compose and transform streams, so that you can keep back-pressure all along the way in a nice functional programming style. All transformation functions can return **Q promises** instead of direct values, which makes asynchronous operations less verbose and more functional (less callback hell!).\n\nExample:\n```js\nvar ee = require('streamee');\n\nvar stream1 = // Readable stream, for example from a HTTP chunked response, a MongoDB response, ...\nvar promiseOfStream = // sometimes, because of callbacks, we can only get a Q.Promise[Readable] instead of a Readable\nvar stream2 = ee.flattenReadable(promiseOfStream) // well, now you can flatten it!\n\nee.pipeAndRun( // create a pipeline\n  ee.interleave([stream1, stream2]), // interleave the streams\n  ee.map(ee.obj, function(obj) { // 'ee.obj' means that we want to handle the chunk as a json object\n    obj.newField = 'something useful'\n    return obj; // return directly a value, so this is a sync map\n  }),\n  ee.collect(ee.obj, function(obj) { // collect is filter + map\n    if (obj.intField > 3 && obj.intField < 10) { // filter\n      return getPromiseOfData(obj); // async map by returning a Q promise\n  }),\n  destination // Writable stream, for example a HTTP chunked response towards a Web client or a Websocket connection\n);\n```\n\nInspired from [Play Framework Enumeratee](http://www.playframework.com/documentation/2.1.1/Enumeratees).\n\n## Installation\n```\nnpm install streamee\n```\n\n## Integrate with other APIs that return streams\nStreamee.js uses node 1.0+ streams, so if you use an API that returns node 0.8 streams, you have to wrap them like this:\n```js\nvar stream = require('stream');\nvar newStream = new stream.Readable().wrap(oldStream);\n```\n\nIf each chunk of your stream is a logical independent unit (for example a stream of json strings),\nyou should create an 'objectMode' stream so that node's stream buffers does not automatically concatenate the chunks:\n```js\nvar objectModeStream = new stream.Readable({objectMode: true}).wrap(nonObjectModeStream);\n```\n\nFor example, here is a function that returns a chunked http response as an objectMode stream:\n```js\nvar http = require('http');\nvar Q = require('q');\n\n// GET a http chunked stream (for example a stream of json strings)\nfunction GETstream(url) {\n  var deferred = Q.defer();\n  http.get(url, function(res) { \n    deferred.resolve(new stream.Readable({objectMode: true}).wrap(res));\n  });\n  return ee.flattenReadable(deferred.promise); // flatten a Promise[stream.Readable] to a stream.Readable\n}\n```\n\n## API\nAll transformers and composers returned by streamee.js are instances of node 1.0+ Stream.\n\nAll transformers (map, filter, collect...) take as first parameter the type in which you want to handle the chunk in the transformation function. ```ee.bin``` is buffer (binary data), ```ee.str``` is string and ```ee.obj``` is an object. If a chunk is not\nconvertible to the asked type, it will be dropped.\n\nAlso, all transformation functions can return either buffer or string or object, as well as Promise[string] or\nPromise[buffer] or Promise[object].\n\nDefault encoding for all transformers is utf8. If a source or a destination has a different encoding, you can use \n```ee.encode(fromEncoding, toEncoding)``` at the begin or the end of the stream pipeline.\n\n---------------------------------------\n\n### ee.map(fromType, f)\nMap each chunk.\n\n**Arguments**\n*  fromType: ee.bin | ee.str | ee.obj\n*  f: function(chunk) - Must return the mapped chunk or a Promise of it\n\n**Example**\n```js\nvar mapper = ee.map(ee.str, function(str) {\n  return str + ' is mapped to this message';\n})\n```\n\n**Example with a promise**\n```js\nvar request = require('request');\n\n// Helper function that does a http GET request and returns a promise of the response body\nfunction GET(url) {\n  var deferred = Q.defer();\n  request(url, function(err, res, body) {\n    if (!err && res.statusCode == 200) deferred.resolve(body)\n    else deferred.reject(err);\n  });\n  return deferred.promise;\n}\n\nvar mapper = ee.map(ee.obj, function(obj) {\n  return GET(obj.url).then(function(body) {\n    return obj + ' is mapped to ' + body;\n  });\n})\n```\n\n---------------------------------------\n\n### ee.filter(fromType, f)\nKeep only the chunks that pass the truth test f.\n\n**Arguments**\n*  fromType: ee.bin | ee.str | ee.obj\n*  f: function(chunk) - Must return a boolean value (indicating if the chunk is kept in the stream) or a Promise of it.\n\n**Example**\n```js\nvar filter = ee.filter(ee.obj, function(obj) {\n  return obj.aField === 'someValue';\n})\n```\n\n---------------------------------------\n\n### ee.collect(fromType, f)\nCollect is filter + map.\n\n**Arguments** \n*  fromType: ee.bin | ee.str | ee.obj\n*  f: function(chunk) - For each chunk, if a value (or a Promise of it) is returned by f, then this chunk is kept in\nthe stream and mapped to the returned value (or the value inside the Promise). If the function does not return (or return \nundefined), the chunk is not kept.\n\n**Example**\n```js\nvar collector = ee.collect(ee.str, function(str) {\n  if (str.length > 10) return 'We keep ' + str + ' and map it to this message';\n})\n```\n\n---------------------------------------\n\n### ee.splitStr(separator)\nRe-chunk a string stream according to separator.\n\n**Arguments** \n*  separator: string or regexp for separating the chunks\n\n**Example**\n```js\nvar splitter = ee.splitStr('\\n'); // one chunk is one line\n```\n\n---------------------------------------\n\n### ee.encode(fromEncoding, toEncoding)\nEncode the chunks that were encoded in 'fromEncoding' to 'toEncoding'.\n\n**Example**\n```js\nvar utf8stream = ee.encode('utf16le', 'utf8');\n```\n\n---------------------------------------\n\n### ee.interleave(arrayOfReadableStreams)\nInterleave the readable streams passed in the array.\n\n**Example**\n```js\nvar mixedStream = ee.interleave([stream1, stream2]);\n```\n\n---------------------------------------\n\n### ee.concatenate(arrayOfReadableStreams)\nConcatenate sequentially the readable streams passed in the array. The resulting stream ends when the last stream of \narrayOfReadableStreams ends.\n\n**Example**\n```js\nvar stream1AndThenStream2 = ee.concatenate([stream1, stream2]);\n```\n\n---------------------------------------\n\n### ee.flattenReadable(readable)\nFlatten a Q.Promise[Readable] to a Readable stream.\n\n**Example**\n```js\nvar aStream = ee.flattenReadable(promiseOfReadableStream);\n```\n\n---------------------------------------\n\n### ee.pipeAndRun(streams*)\nTake the streams passed in parameter and sequentially pipe them. Equivalent to stream1.pipe(stream2).pipe(...) ...\n\n**Example**\n```js\nee.pipeAndRun(\n  srcStream,\n  ee.map(ee.obj, function(obj) {\n    var mappedObj = // ...\n    return mappedObj;\n  }),\n  destinationStream\n);\n```\n\n---------------------------------------\n\n### More to come!\n\n## License\nThis software is licensed under the Apache 2 license, quoted below.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n",
  "readmeFilename": "README.md",
  "_id": "streamee@0.5.3",
  "_from": "streamee@^0.5.3"
}
